/* tslint:disable */
/* eslint-disable */
/**
 * Tapis Security API
 * The Tapis Security API provides access to the Tapis Security Kernel authorization and secrets facilities.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: cicsupport@tacc.utexas.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ReqGrantAdminRole,
    ReqGrantAdminRoleFromJSON,
    ReqGrantAdminRoleToJSON,
    ReqGrantUserPermission,
    ReqGrantUserPermissionFromJSON,
    ReqGrantUserPermissionToJSON,
    ReqGrantUserRole,
    ReqGrantUserRoleFromJSON,
    ReqGrantUserRoleToJSON,
    ReqGrantUserRoleWithPermission,
    ReqGrantUserRoleWithPermissionFromJSON,
    ReqGrantUserRoleWithPermissionToJSON,
    ReqRevokeAdminRole,
    ReqRevokeAdminRoleFromJSON,
    ReqRevokeAdminRoleToJSON,
    ReqRevokeUserPermission,
    ReqRevokeUserPermissionFromJSON,
    ReqRevokeUserPermissionToJSON,
    ReqRevokeUserRole,
    ReqRevokeUserRoleFromJSON,
    ReqRevokeUserRoleToJSON,
    ReqUserHasRole,
    ReqUserHasRoleFromJSON,
    ReqUserHasRoleToJSON,
    ReqUserHasRoleMulti,
    ReqUserHasRoleMultiFromJSON,
    ReqUserHasRoleMultiToJSON,
    ReqUserIsAdmin,
    ReqUserIsAdminFromJSON,
    ReqUserIsAdminToJSON,
    ReqUserIsPermitted,
    ReqUserIsPermittedFromJSON,
    ReqUserIsPermittedToJSON,
    ReqUserIsPermittedMulti,
    ReqUserIsPermittedMultiFromJSON,
    ReqUserIsPermittedMultiToJSON,
    RespAuthorized,
    RespAuthorizedFromJSON,
    RespAuthorizedToJSON,
    RespBasic,
    RespBasicFromJSON,
    RespBasicToJSON,
    RespChangeCount,
    RespChangeCountFromJSON,
    RespChangeCountToJSON,
    RespName,
    RespNameFromJSON,
    RespNameToJSON,
    RespNameArray,
    RespNameArrayFromJSON,
    RespNameArrayToJSON,
} from '../models';

export interface GetAdminsRequest {
    tenant: string;
    pretty?: boolean;
}

export interface GetDefaultUserRole1Request {
    user: string;
    pretty?: boolean;
}

export interface GetUserNamesRequest {
    tenant?: string;
    pretty?: boolean;
}

export interface GetUserPermsRequest {
    user: string;
    tenant?: string;
    implies?: string;
    impliedBy?: string;
    pretty?: boolean;
}

export interface GetUserRolesRequest {
    user: string;
    tenant?: string;
    pretty?: boolean;
}

export interface GetUsersWithPermissionRequest {
    permSpec: string;
    tenant?: string;
    pretty?: boolean;
}

export interface GetUsersWithRoleRequest {
    roleName: string;
    tenant?: string;
    pretty?: boolean;
}

export interface GrantAdminRoleRequest {
    reqGrantAdminRole: ReqGrantAdminRole;
    pretty?: boolean;
}

export interface GrantRoleRequest {
    reqGrantUserRole: ReqGrantUserRole;
    pretty?: boolean;
}

export interface GrantRoleWithPermissionRequest {
    reqGrantUserRoleWithPermission: ReqGrantUserRoleWithPermission;
    pretty?: boolean;
}

export interface GrantUserPermissionRequest {
    reqGrantUserPermission: ReqGrantUserPermission;
    pretty?: boolean;
}

export interface HasRoleRequest {
    reqUserHasRole: ReqUserHasRole;
    pretty?: boolean;
}

export interface HasRoleAllRequest {
    reqUserHasRoleMulti: ReqUserHasRoleMulti;
    pretty?: boolean;
}

export interface HasRoleAnyRequest {
    reqUserHasRoleMulti: ReqUserHasRoleMulti;
    pretty?: boolean;
}

export interface IsAdminRequest {
    reqUserIsAdmin: ReqUserIsAdmin;
    pretty?: boolean;
}

export interface IsPermittedRequest {
    reqUserIsPermitted: ReqUserIsPermitted;
    pretty?: boolean;
}

export interface IsPermittedAllRequest {
    reqUserIsPermittedMulti: ReqUserIsPermittedMulti;
    pretty?: boolean;
}

export interface IsPermittedAnyRequest {
    reqUserIsPermittedMulti: ReqUserIsPermittedMulti;
    pretty?: boolean;
}

export interface RevokeAdminRoleRequest {
    reqRevokeAdminRole: ReqRevokeAdminRole;
    pretty?: boolean;
}

export interface RevokeUserPermissionRequest {
    reqRevokeUserPermission: ReqRevokeUserPermission;
    pretty?: boolean;
}

export interface RevokeUserRoleRequest {
    reqRevokeUserRole: ReqRevokeUserRole;
    pretty?: boolean;
}

/**
 * 
 */
export class UserApi extends runtime.BaseAPI {

    /**
     * Get all users assigned the tenant administrator role ($!tenant_admin).  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getAdminsRaw(requestParameters: GetAdminsRequest): Promise<runtime.ApiResponse<RespNameArray>> {
        if (requestParameters.tenant === null || requestParameters.tenant === undefined) {
            throw new runtime.RequiredError('tenant','Required parameter requestParameters.tenant was null or undefined when calling getAdmins.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/admins/{tenant}`.replace(`{${"tenant"}}`, encodeURIComponent(String(requestParameters.tenant))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespNameArrayFromJSON(jsonValue));
    }

    /**
     * Get all users assigned the tenant administrator role ($!tenant_admin).  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getAdmins(requestParameters: GetAdminsRequest): Promise<RespNameArray> {
        const response = await this.getAdminsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a user\'s default role. The default role is implicitly created by the system when needed if it doesn\'t already exist. No authorization required.  A user\'s default role is constructed by prepending \'$$\' to the user\'s name.  This implies the maximum length of a user name is 58 since role names are limited to 60 characters.
     */
    async getDefaultUserRole1Raw(requestParameters: GetDefaultUserRole1Request): Promise<runtime.ApiResponse<RespName>> {
        if (requestParameters.user === null || requestParameters.user === undefined) {
            throw new runtime.RequiredError('user','Required parameter requestParameters.user was null or undefined when calling getDefaultUserRole1.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/security/user/defaultRole/{user}`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters.user))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespNameFromJSON(jsonValue));
    }

    /**
     * Get a user\'s default role. The default role is implicitly created by the system when needed if it doesn\'t already exist. No authorization required.  A user\'s default role is constructed by prepending \'$$\' to the user\'s name.  This implies the maximum length of a user name is 58 since role names are limited to 60 characters.
     */
    async getDefaultUserRole1(requestParameters: GetDefaultUserRole1Request): Promise<RespName> {
        const response = await this.getDefaultUserRole1Raw(requestParameters);
        return await response.value();
    }

    /**
     * Get the names of all users in the tenant that have been granted a role or permission.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getUserNamesRaw(requestParameters: GetUserNamesRequest): Promise<runtime.ApiResponse<RespNameArray>> {
        const queryParameters: any = {};

        if (requestParameters.tenant !== undefined) {
            queryParameters['tenant'] = requestParameters.tenant;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespNameArrayFromJSON(jsonValue));
    }

    /**
     * Get the names of all users in the tenant that have been granted a role or permission.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getUserNames(requestParameters: GetUserNamesRequest): Promise<RespNameArray> {
        const response = await this.getUserNamesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the permissions assigned to a user in a tenant, including those assigned transively.  The result list can be optionally filtered by the one or both of the query parameters: implies and impliedBy.  The implied parameter removes permissions from the result list that the specified permission do not imply. The impliedBy parameter removes permissions from the result list that the specified permission are not implied by. Below are some examples.Consider a user that is assigned these permissions:      stream:dev:read:project1     stream:dev:read,write:project1     stream:dev:read,write,exec:project1  **Using the *implies* Query Parameter**  When _implies=stream:dev:*:project1_, this endpoint returns:      stream:dev:read:project1     stream:dev:read,write:project1     stream:dev:read,write,exec:project1  When _implies=stream:dev:write:project1_, this endpoint returns an empty list.  **Using the *impliedBy* Query Parameter**  When _impliedBy=stream:dev:*:project1_, this endpoint returns an empty list.  When _impliedBy=stream:dev:write:project1_, this endpoint returns:      stream:dev:read,write:project1     stream:dev:read,write,exec:project1  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getUserPermsRaw(requestParameters: GetUserPermsRequest): Promise<runtime.ApiResponse<RespNameArray>> {
        if (requestParameters.user === null || requestParameters.user === undefined) {
            throw new runtime.RequiredError('user','Required parameter requestParameters.user was null or undefined when calling getUserPerms.');
        }

        const queryParameters: any = {};

        if (requestParameters.tenant !== undefined) {
            queryParameters['tenant'] = requestParameters.tenant;
        }

        if (requestParameters.implies !== undefined) {
            queryParameters['implies'] = requestParameters.implies;
        }

        if (requestParameters.impliedBy !== undefined) {
            queryParameters['impliedBy'] = requestParameters.impliedBy;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/perms/{user}`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters.user))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespNameArrayFromJSON(jsonValue));
    }

    /**
     * Get the permissions assigned to a user in a tenant, including those assigned transively.  The result list can be optionally filtered by the one or both of the query parameters: implies and impliedBy.  The implied parameter removes permissions from the result list that the specified permission do not imply. The impliedBy parameter removes permissions from the result list that the specified permission are not implied by. Below are some examples.Consider a user that is assigned these permissions:      stream:dev:read:project1     stream:dev:read,write:project1     stream:dev:read,write,exec:project1  **Using the *implies* Query Parameter**  When _implies=stream:dev:*:project1_, this endpoint returns:      stream:dev:read:project1     stream:dev:read,write:project1     stream:dev:read,write,exec:project1  When _implies=stream:dev:write:project1_, this endpoint returns an empty list.  **Using the *impliedBy* Query Parameter**  When _impliedBy=stream:dev:*:project1_, this endpoint returns an empty list.  When _impliedBy=stream:dev:write:project1_, this endpoint returns:      stream:dev:read,write:project1     stream:dev:read,write,exec:project1  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getUserPerms(requestParameters: GetUserPermsRequest): Promise<RespNameArray> {
        const response = await this.getUserPermsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the roles assigned to a user in the specified tenant, including those assigned transively.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getUserRolesRaw(requestParameters: GetUserRolesRequest): Promise<runtime.ApiResponse<RespNameArray>> {
        if (requestParameters.user === null || requestParameters.user === undefined) {
            throw new runtime.RequiredError('user','Required parameter requestParameters.user was null or undefined when calling getUserRoles.');
        }

        const queryParameters: any = {};

        if (requestParameters.tenant !== undefined) {
            queryParameters['tenant'] = requestParameters.tenant;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/roles/{user}`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters.user))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespNameArrayFromJSON(jsonValue));
    }

    /**
     * Get the roles assigned to a user in the specified tenant, including those assigned transively.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getUserRoles(requestParameters: GetUserRolesRequest): Promise<RespNameArray> {
        const response = await this.getUserRolesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all users in a tenant assigned a permission.  The permSpec parameter is a permission specification that uses colons as separators, the asterisk as a wildcard character and commas to define lists.  Here are examples of permission specifications:      system:mytenant:read:mysystem     system:mytenant:*:mysystem     system:mytenant     files:mytenant:read,write:mysystems This method recognizes the percent sign (%) as a string wildcard only in the context of database searching.  If a percent sign (%) appears in the permSpec it is interpreted as a zero or more character wildcard.  For example, the following specification would match the first three of the above example specifications but not the fourth:      system:mytenant:%  The wildcard character cannot appear as the first character in the permSpec.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getUsersWithPermissionRaw(requestParameters: GetUsersWithPermissionRequest): Promise<runtime.ApiResponse<RespNameArray>> {
        if (requestParameters.permSpec === null || requestParameters.permSpec === undefined) {
            throw new runtime.RequiredError('permSpec','Required parameter requestParameters.permSpec was null or undefined when calling getUsersWithPermission.');
        }

        const queryParameters: any = {};

        if (requestParameters.tenant !== undefined) {
            queryParameters['tenant'] = requestParameters.tenant;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/withPermission/{permSpec}`.replace(`{${"permSpec"}}`, encodeURIComponent(String(requestParameters.permSpec))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespNameArrayFromJSON(jsonValue));
    }

    /**
     * Get all users in a tenant assigned a permission.  The permSpec parameter is a permission specification that uses colons as separators, the asterisk as a wildcard character and commas to define lists.  Here are examples of permission specifications:      system:mytenant:read:mysystem     system:mytenant:*:mysystem     system:mytenant     files:mytenant:read,write:mysystems This method recognizes the percent sign (%) as a string wildcard only in the context of database searching.  If a percent sign (%) appears in the permSpec it is interpreted as a zero or more character wildcard.  For example, the following specification would match the first three of the above example specifications but not the fourth:      system:mytenant:%  The wildcard character cannot appear as the first character in the permSpec.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getUsersWithPermission(requestParameters: GetUsersWithPermissionRequest): Promise<RespNameArray> {
        const response = await this.getUsersWithPermissionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all users assigned a role.  The role must exist in the tenant.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getUsersWithRoleRaw(requestParameters: GetUsersWithRoleRequest): Promise<runtime.ApiResponse<RespNameArray>> {
        if (requestParameters.roleName === null || requestParameters.roleName === undefined) {
            throw new runtime.RequiredError('roleName','Required parameter requestParameters.roleName was null or undefined when calling getUsersWithRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.tenant !== undefined) {
            queryParameters['tenant'] = requestParameters.tenant;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/withRole/{roleName}`.replace(`{${"roleName"}}`, encodeURIComponent(String(requestParameters.roleName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespNameArrayFromJSON(jsonValue));
    }

    /**
     * Get all users assigned a role.  The role must exist in the tenant.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getUsersWithRole(requestParameters: GetUsersWithRoleRequest): Promise<RespNameArray> {
        const response = await this.getUsersWithRoleRaw(requestParameters);
        return await response.value();
    }

    /**
     * Grant a user the tenant administrator role.  A valid tenant and user must be specified in the request body.  The user specified in the JWT must be an administrator in the tenant specified in the request body.
     */
    async grantAdminRoleRaw(requestParameters: GrantAdminRoleRequest): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqGrantAdminRole === null || requestParameters.reqGrantAdminRole === undefined) {
            throw new runtime.RequiredError('reqGrantAdminRole','Required parameter requestParameters.reqGrantAdminRole was null or undefined when calling grantAdminRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/grantAdminRole`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqGrantAdminRoleToJSON(requestParameters.reqGrantAdminRole),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Grant a user the tenant administrator role.  A valid tenant and user must be specified in the request body.  The user specified in the JWT must be an administrator in the tenant specified in the request body.
     */
    async grantAdminRole(requestParameters: GrantAdminRoleRequest): Promise<RespChangeCount> {
        const response = await this.grantAdminRoleRaw(requestParameters);
        return await response.value();
    }

    /**
     * Grant a user the specified role.  A valid tenant and user must be specified in the request body.  This request is authorized only if the requestor is the role owner or an administrator.  The user and the role must be in the same tenant.
     */
    async grantRoleRaw(requestParameters: GrantRoleRequest): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqGrantUserRole === null || requestParameters.reqGrantUserRole === undefined) {
            throw new runtime.RequiredError('reqGrantUserRole','Required parameter requestParameters.reqGrantUserRole was null or undefined when calling grantRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/grantRole`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqGrantUserRoleToJSON(requestParameters.reqGrantUserRole),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Grant a user the specified role.  A valid tenant and user must be specified in the request body.  This request is authorized only if the requestor is the role owner or an administrator.  The user and the role must be in the same tenant.
     */
    async grantRole(requestParameters: GrantRoleRequest): Promise<RespChangeCount> {
        const response = await this.grantRoleRaw(requestParameters);
        return await response.value();
    }

    /**
     * Grant a user the specified role containing the specified permission.  This compound request first adds the permission to the role if it is not already a member of the role and then assigns the role to the user.  The change count returned can range from zero to two depending on how many insertions were actually required.  Only the role owner or an administrator is authorized to make this request.  The user and the role must be in the same tenant.
     */
    async grantRoleWithPermissionRaw(requestParameters: GrantRoleWithPermissionRequest): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqGrantUserRoleWithPermission === null || requestParameters.reqGrantUserRoleWithPermission === undefined) {
            throw new runtime.RequiredError('reqGrantUserRoleWithPermission','Required parameter requestParameters.reqGrantUserRoleWithPermission was null or undefined when calling grantRoleWithPermission.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/grantRoleWithPerm`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqGrantUserRoleWithPermissionToJSON(requestParameters.reqGrantUserRoleWithPermission),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Grant a user the specified role containing the specified permission.  This compound request first adds the permission to the role if it is not already a member of the role and then assigns the role to the user.  The change count returned can range from zero to two depending on how many insertions were actually required.  Only the role owner or an administrator is authorized to make this request.  The user and the role must be in the same tenant.
     */
    async grantRoleWithPermission(requestParameters: GrantRoleWithPermissionRequest): Promise<RespChangeCount> {
        const response = await this.grantRoleWithPermissionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Grant a user the specified permission by assigning that permission to to the user\'s default role.  If the user\'s default role does not exist,this request will create that role and grant it to the user before assigning the permission to the role.  A user\'s default role name is discoverable by calling either of the user/defaultRole or role/defaultRole endpoints.  The change count returned can range from zero to three depending on how many insertions and updates were actually required  The caller must be an administrator or service allowed to perform updates in the user\'s tenant.
     */
    async grantUserPermissionRaw(requestParameters: GrantUserPermissionRequest): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqGrantUserPermission === null || requestParameters.reqGrantUserPermission === undefined) {
            throw new runtime.RequiredError('reqGrantUserPermission','Required parameter requestParameters.reqGrantUserPermission was null or undefined when calling grantUserPermission.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/grantUserPermission`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqGrantUserPermissionToJSON(requestParameters.reqGrantUserPermission),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Grant a user the specified permission by assigning that permission to to the user\'s default role.  If the user\'s default role does not exist,this request will create that role and grant it to the user before assigning the permission to the role.  A user\'s default role name is discoverable by calling either of the user/defaultRole or role/defaultRole endpoints.  The change count returned can range from zero to three depending on how many insertions and updates were actually required  The caller must be an administrator or service allowed to perform updates in the user\'s tenant.
     */
    async grantUserPermission(requestParameters: GrantUserPermissionRequest): Promise<RespChangeCount> {
        const response = await this.grantUserPermissionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Check whether a user in a tenant has been assigned the specified role, either directly or transitively.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async hasRoleRaw(requestParameters: HasRoleRequest): Promise<runtime.ApiResponse<RespAuthorized>> {
        if (requestParameters.reqUserHasRole === null || requestParameters.reqUserHasRole === undefined) {
            throw new runtime.RequiredError('reqUserHasRole','Required parameter requestParameters.reqUserHasRole was null or undefined when calling hasRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/hasRole`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqUserHasRoleToJSON(requestParameters.reqUserHasRole),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAuthorizedFromJSON(jsonValue));
    }

    /**
     * Check whether a user in a tenant has been assigned the specified role, either directly or transitively.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async hasRole(requestParameters: HasRoleRequest): Promise<RespAuthorized> {
        const response = await this.hasRoleRaw(requestParameters);
        return await response.value();
    }

    /**
     * Check whether a user in a tenant has been assigned all of the roles specified in the request body.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async hasRoleAllRaw(requestParameters: HasRoleAllRequest): Promise<runtime.ApiResponse<RespAuthorized>> {
        if (requestParameters.reqUserHasRoleMulti === null || requestParameters.reqUserHasRoleMulti === undefined) {
            throw new runtime.RequiredError('reqUserHasRoleMulti','Required parameter requestParameters.reqUserHasRoleMulti was null or undefined when calling hasRoleAll.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/hasRoleAll`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqUserHasRoleMultiToJSON(requestParameters.reqUserHasRoleMulti),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAuthorizedFromJSON(jsonValue));
    }

    /**
     * Check whether a user in a tenant has been assigned all of the roles specified in the request body.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async hasRoleAll(requestParameters: HasRoleAllRequest): Promise<RespAuthorized> {
        const response = await this.hasRoleAllRaw(requestParameters);
        return await response.value();
    }

    /**
     * Check whether a user in a tenant has been assigned any of the roles specified in the request body.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async hasRoleAnyRaw(requestParameters: HasRoleAnyRequest): Promise<runtime.ApiResponse<RespAuthorized>> {
        if (requestParameters.reqUserHasRoleMulti === null || requestParameters.reqUserHasRoleMulti === undefined) {
            throw new runtime.RequiredError('reqUserHasRoleMulti','Required parameter requestParameters.reqUserHasRoleMulti was null or undefined when calling hasRoleAny.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/hasRoleAny`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqUserHasRoleMultiToJSON(requestParameters.reqUserHasRoleMulti),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAuthorizedFromJSON(jsonValue));
    }

    /**
     * Check whether a user in a tenant has been assigned any of the roles specified in the request body.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async hasRoleAny(requestParameters: HasRoleAnyRequest): Promise<RespAuthorized> {
        const response = await this.hasRoleAnyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Check whether a user in a tenant has been assigned the tenant administrator role, either directly or transitively.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async isAdminRaw(requestParameters: IsAdminRequest): Promise<runtime.ApiResponse<RespAuthorized>> {
        if (requestParameters.reqUserIsAdmin === null || requestParameters.reqUserIsAdmin === undefined) {
            throw new runtime.RequiredError('reqUserIsAdmin','Required parameter requestParameters.reqUserIsAdmin was null or undefined when calling isAdmin.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/isAdmin`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqUserIsAdminToJSON(requestParameters.reqUserIsAdmin),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAuthorizedFromJSON(jsonValue));
    }

    /**
     * Check whether a user in a tenant has been assigned the tenant administrator role, either directly or transitively.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async isAdmin(requestParameters: IsAdminRequest): Promise<RespAuthorized> {
        const response = await this.isAdminRaw(requestParameters);
        return await response.value();
    }

    /**
     * Check whether specified permission matches a permission assigned to the user, either directly or transitively.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async isPermittedRaw(requestParameters: IsPermittedRequest): Promise<runtime.ApiResponse<RespAuthorized>> {
        if (requestParameters.reqUserIsPermitted === null || requestParameters.reqUserIsPermitted === undefined) {
            throw new runtime.RequiredError('reqUserIsPermitted','Required parameter requestParameters.reqUserIsPermitted was null or undefined when calling isPermitted.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/isPermitted`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqUserIsPermittedToJSON(requestParameters.reqUserIsPermitted),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAuthorizedFromJSON(jsonValue));
    }

    /**
     * Check whether specified permission matches a permission assigned to the user, either directly or transitively.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async isPermitted(requestParameters: IsPermittedRequest): Promise<RespAuthorized> {
        const response = await this.isPermittedRaw(requestParameters);
        return await response.value();
    }

    /**
     * Check whether a user\'s permissions satisfy all of the permission specifications contained in the request body.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async isPermittedAllRaw(requestParameters: IsPermittedAllRequest): Promise<runtime.ApiResponse<RespAuthorized>> {
        if (requestParameters.reqUserIsPermittedMulti === null || requestParameters.reqUserIsPermittedMulti === undefined) {
            throw new runtime.RequiredError('reqUserIsPermittedMulti','Required parameter requestParameters.reqUserIsPermittedMulti was null or undefined when calling isPermittedAll.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/isPermittedAll`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqUserIsPermittedMultiToJSON(requestParameters.reqUserIsPermittedMulti),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAuthorizedFromJSON(jsonValue));
    }

    /**
     * Check whether a user\'s permissions satisfy all of the permission specifications contained in the request body.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async isPermittedAll(requestParameters: IsPermittedAllRequest): Promise<RespAuthorized> {
        const response = await this.isPermittedAllRaw(requestParameters);
        return await response.value();
    }

    /**
     * Check whether a user\'s permissions satisfy any of the permission specifications contained in the request body.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async isPermittedAnyRaw(requestParameters: IsPermittedAnyRequest): Promise<runtime.ApiResponse<RespAuthorized>> {
        if (requestParameters.reqUserIsPermittedMulti === null || requestParameters.reqUserIsPermittedMulti === undefined) {
            throw new runtime.RequiredError('reqUserIsPermittedMulti','Required parameter requestParameters.reqUserIsPermittedMulti was null or undefined when calling isPermittedAny.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/isPermittedAny`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqUserIsPermittedMultiToJSON(requestParameters.reqUserIsPermittedMulti),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAuthorizedFromJSON(jsonValue));
    }

    /**
     * Check whether a user\'s permissions satisfy any of the permission specifications contained in the request body.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async isPermittedAny(requestParameters: IsPermittedAnyRequest): Promise<RespAuthorized> {
        const response = await this.isPermittedAnyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Revoke the previously granted tenant administrator role from a user. No action is taken if the user is not currently assigned the role (the request is idempotent).  The request will not be honored if revoking the role would leave the tenant with no administrator.  The user specified in the JWT must themselves be an administrator and a valid tenant and user must be specified in the request body.
     */
    async revokeAdminRoleRaw(requestParameters: RevokeAdminRoleRequest): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqRevokeAdminRole === null || requestParameters.reqRevokeAdminRole === undefined) {
            throw new runtime.RequiredError('reqRevokeAdminRole','Required parameter requestParameters.reqRevokeAdminRole was null or undefined when calling revokeAdminRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/revokeAdminRole`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqRevokeAdminRoleToJSON(requestParameters.reqRevokeAdminRole),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Revoke the previously granted tenant administrator role from a user. No action is taken if the user is not currently assigned the role (the request is idempotent).  The request will not be honored if revoking the role would leave the tenant with no administrator.  The user specified in the JWT must themselves be an administrator and a valid tenant and user must be specified in the request body.
     */
    async revokeAdminRole(requestParameters: RevokeAdminRoleRequest): Promise<RespChangeCount> {
        const response = await this.revokeAdminRoleRaw(requestParameters);
        return await response.value();
    }

    /**
     * Revoke the specified permission from the user\'s default role. A user\'s default role is constructed by prepending \'$$\' to the user\'s name. Default roles are created on demand. If the role does not exist when this method is called no error is reported and no changes occur.  The change count returned can be zero or one depending on how many permissions were revoked.  A valid tenant and user must be specified in the request body.  The caller must be an administrator, a service or the user themselves.
     */
    async revokeUserPermissionRaw(requestParameters: RevokeUserPermissionRequest): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqRevokeUserPermission === null || requestParameters.reqRevokeUserPermission === undefined) {
            throw new runtime.RequiredError('reqRevokeUserPermission','Required parameter requestParameters.reqRevokeUserPermission was null or undefined when calling revokeUserPermission.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/revokeUserPermission`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqRevokeUserPermissionToJSON(requestParameters.reqRevokeUserPermission),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Revoke the specified permission from the user\'s default role. A user\'s default role is constructed by prepending \'$$\' to the user\'s name. Default roles are created on demand. If the role does not exist when this method is called no error is reported and no changes occur.  The change count returned can be zero or one depending on how many permissions were revoked.  A valid tenant and user must be specified in the request body.  The caller must be an administrator, a service or the user themselves.
     */
    async revokeUserPermission(requestParameters: RevokeUserPermissionRequest): Promise<RespChangeCount> {
        const response = await this.revokeUserPermissionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Revoke a previously granted role from a user. No action is taken if the user is not currently assigned the role. This request is idempotent.  This request is authorized only if the requestor is the role owner or an administrator.
     */
    async revokeUserRoleRaw(requestParameters: RevokeUserRoleRequest): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqRevokeUserRole === null || requestParameters.reqRevokeUserRole === undefined) {
            throw new runtime.RequiredError('reqRevokeUserRole','Required parameter requestParameters.reqRevokeUserRole was null or undefined when calling revokeUserRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/user/revokeUserRole`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqRevokeUserRoleToJSON(requestParameters.reqRevokeUserRole),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Revoke a previously granted role from a user. No action is taken if the user is not currently assigned the role. This request is idempotent.  This request is authorized only if the requestor is the role owner or an administrator.
     */
    async revokeUserRole(requestParameters: RevokeUserRoleRequest): Promise<RespChangeCount> {
        const response = await this.revokeUserRoleRaw(requestParameters);
        return await response.value();
    }

}
