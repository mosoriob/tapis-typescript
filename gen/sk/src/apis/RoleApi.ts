/* tslint:disable */
/* eslint-disable */
/**
 * Tapis Security API
 * The Tapis Security API provides access to the Tapis Security Kernel authorization and secrets facilities.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: cicsupport@tacc.utexas.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ReqAddChildRole,
    ReqAddChildRoleFromJSON,
    ReqAddChildRoleToJSON,
    ReqAddRolePermission,
    ReqAddRolePermissionFromJSON,
    ReqAddRolePermissionToJSON,
    ReqCreateRole,
    ReqCreateRoleFromJSON,
    ReqCreateRoleToJSON,
    ReqPreviewPathPrefix,
    ReqPreviewPathPrefixFromJSON,
    ReqPreviewPathPrefixToJSON,
    ReqRemoveChildRole,
    ReqRemoveChildRoleFromJSON,
    ReqRemoveChildRoleToJSON,
    ReqRemoveRolePermission,
    ReqRemoveRolePermissionFromJSON,
    ReqRemoveRolePermissionToJSON,
    ReqReplacePathPrefix,
    ReqReplacePathPrefixFromJSON,
    ReqReplacePathPrefixToJSON,
    ReqUpdateRoleDescription,
    ReqUpdateRoleDescriptionFromJSON,
    ReqUpdateRoleDescriptionToJSON,
    ReqUpdateRoleName,
    ReqUpdateRoleNameFromJSON,
    ReqUpdateRoleNameToJSON,
    ReqUpdateRoleOwner,
    ReqUpdateRoleOwnerFromJSON,
    ReqUpdateRoleOwnerToJSON,
    RespBasic,
    RespBasicFromJSON,
    RespBasicToJSON,
    RespChangeCount,
    RespChangeCountFromJSON,
    RespChangeCountToJSON,
    RespName,
    RespNameFromJSON,
    RespNameToJSON,
    RespNameArray,
    RespNameArrayFromJSON,
    RespNameArrayToJSON,
    RespPathPrefixes,
    RespPathPrefixesFromJSON,
    RespPathPrefixesToJSON,
    RespResourceUrl,
    RespResourceUrlFromJSON,
    RespResourceUrlToJSON,
    RespRole,
    RespRoleFromJSON,
    RespRoleToJSON,
} from '../models';

export interface AddChildRoleRequest {
    reqAddChildRole: ReqAddChildRole;
    pretty?: boolean;
}

export interface AddRolePermissionRequest {
    reqAddRolePermission: ReqAddRolePermission;
    pretty?: boolean;
}

export interface CreateRoleRequest {
    reqCreateRole: ReqCreateRole;
    pretty?: boolean;
}

export interface DeleteRoleByNameRequest {
    roleName: string;
    tenant?: string;
    pretty?: boolean;
}

export interface GetDefaultUserRoleRequest {
    user: string;
    pretty?: boolean;
}

export interface GetRoleByNameRequest {
    roleName: string;
    tenant?: string;
    pretty?: boolean;
}

export interface GetRoleNamesRequest {
    tenant?: string;
    pretty?: boolean;
}

export interface GetRolePermissionsRequest {
    roleName: string;
    tenant?: string;
    immediate?: boolean;
    pretty?: boolean;
}

export interface PreviewPathPrefixRequest {
    reqPreviewPathPrefix: ReqPreviewPathPrefix;
    pretty?: boolean;
}

export interface RemoveChildRoleRequest {
    reqRemoveChildRole: ReqRemoveChildRole;
    pretty?: boolean;
}

export interface RemoveRolePermissionRequest {
    reqRemoveRolePermission: ReqRemoveRolePermission;
    pretty?: boolean;
}

export interface ReplacePathPrefixRequest {
    reqReplacePathPrefix: ReqReplacePathPrefix;
    pretty?: boolean;
}

export interface UpdateRoleDescriptionRequest {
    roleName: string;
    reqUpdateRoleDescription: ReqUpdateRoleDescription;
    pretty?: boolean;
}

export interface UpdateRoleNameRequest {
    roleName: string;
    reqUpdateRoleName: ReqUpdateRoleName;
    pretty?: boolean;
}

export interface UpdateRoleOwnerRequest {
    roleName: string;
    reqUpdateRoleOwner: ReqUpdateRoleOwner;
    pretty?: boolean;
}

/**
 * 
 */
export class RoleApi extends runtime.BaseAPI {

    /**
     * Add a child role to another role using a request body.  If the child already exists, then the request has no effect and the change count returned is zero. Otherwise, the child is added and the change count is one.  The user@tenant identity specified in JWT is authorized to make this request only if that user is an administrator or if the user owns both the parent and child roles.
     */
    async addChildRoleRaw(requestParameters: AddChildRoleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqAddChildRole === null || requestParameters.reqAddChildRole === undefined) {
            throw new runtime.RequiredError('reqAddChildRole','Required parameter requestParameters.reqAddChildRole was null or undefined when calling addChildRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/addChild`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqAddChildRoleToJSON(requestParameters.reqAddChildRole),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Add a child role to another role using a request body.  If the child already exists, then the request has no effect and the change count returned is zero. Otherwise, the child is added and the change count is one.  The user@tenant identity specified in JWT is authorized to make this request only if that user is an administrator or if the user owns both the parent and child roles.
     */
    async addChildRole(requestParameters: AddChildRoleRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.addChildRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a permission to an existing role using a request body.  If the permission already exists, then the request has no effect and the change count returned is zero. Otherwise, the permission is added and the change count is one.  Permissions are case-sensitive strings that follow the format defined by Apache Shiro (https://shiro.apache.org/permissions.html).  This format defines any number of colon-separated (:) parts, with the possible use of asterisks (*) as wildcards and commas (,) as aggregators.  Here are two example permission strings:      system:MyTenant:read,write:system1     system:MyTenant:create,read,write,delete:*  See the Shiro documentation for further details.  Note that the three reserved characters, [: * ,], cannot appear in the text of any part.  It\'s the application\'s responsibility to escape those characters in a manner that is safe in the application\'s domain.  This request is authorized only if the authenticated user is either the role owner or an administrator.
     */
    async addRolePermissionRaw(requestParameters: AddRolePermissionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqAddRolePermission === null || requestParameters.reqAddRolePermission === undefined) {
            throw new runtime.RequiredError('reqAddRolePermission','Required parameter requestParameters.reqAddRolePermission was null or undefined when calling addRolePermission.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/addPerm`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqAddRolePermissionToJSON(requestParameters.reqAddRolePermission),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Add a permission to an existing role using a request body.  If the permission already exists, then the request has no effect and the change count returned is zero. Otherwise, the permission is added and the change count is one.  Permissions are case-sensitive strings that follow the format defined by Apache Shiro (https://shiro.apache.org/permissions.html).  This format defines any number of colon-separated (:) parts, with the possible use of asterisks (*) as wildcards and commas (,) as aggregators.  Here are two example permission strings:      system:MyTenant:read,write:system1     system:MyTenant:create,read,write,delete:*  See the Shiro documentation for further details.  Note that the three reserved characters, [: * ,], cannot appear in the text of any part.  It\'s the application\'s responsibility to escape those characters in a manner that is safe in the application\'s domain.  This request is authorized only if the authenticated user is either the role owner or an administrator.
     */
    async addRolePermission(requestParameters: AddRolePermissionRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.addRolePermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a role using a request body.  Role names are case sensitive, alpha-numeric strings that can also contain underscores.  Role names must start with an alphbetic character and can be no more than 58 characters in length.  The desciption can be no more than 2048 characters long.  If the role already exists, this request has no effect.  For the request to be authorized, the requestor must be either an administrator or a service allowed to perform updates in the new role\'s tenant.
     */
    async createRoleRaw(requestParameters: CreateRoleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespResourceUrl>> {
        if (requestParameters.reqCreateRole === null || requestParameters.reqCreateRole === undefined) {
            throw new runtime.RequiredError('reqCreateRole','Required parameter requestParameters.reqCreateRole was null or undefined when calling createRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqCreateRoleToJSON(requestParameters.reqCreateRole),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespResourceUrlFromJSON(jsonValue));
    }

    /**
     * Create a role using a request body.  Role names are case sensitive, alpha-numeric strings that can also contain underscores.  Role names must start with an alphbetic character and can be no more than 58 characters in length.  The desciption can be no more than 2048 characters long.  If the role already exists, this request has no effect.  For the request to be authorized, the requestor must be either an administrator or a service allowed to perform updates in the new role\'s tenant.
     */
    async createRole(requestParameters: CreateRoleRequest, initOverrides?: RequestInit): Promise<RespResourceUrl> {
        const response = await this.createRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the named role. A valid tenant and user must be specified as query parameters.  This request is authorized only if the authenticated user is either the role owner or an administrator.
     */
    async deleteRoleByNameRaw(requestParameters: DeleteRoleByNameRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.roleName === null || requestParameters.roleName === undefined) {
            throw new runtime.RequiredError('roleName','Required parameter requestParameters.roleName was null or undefined when calling deleteRoleByName.');
        }

        const queryParameters: any = {};

        if (requestParameters.tenant !== undefined) {
            queryParameters['tenant'] = requestParameters.tenant;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/{roleName}`.replace(`{${"roleName"}}`, encodeURIComponent(String(requestParameters.roleName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Delete the named role. A valid tenant and user must be specified as query parameters.  This request is authorized only if the authenticated user is either the role owner or an administrator.
     */
    async deleteRoleByName(requestParameters: DeleteRoleByNameRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.deleteRoleByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a user\'s default role. The default role is implicitly created by the system when needed if it doesn\'t already exist. No authorization required.  A user\'s default role is constructed by prepending \'$$\' to the user\'s name.  This implies the maximum length of a user name is 58 since role names are limited to 60 characters.  
     */
    async getDefaultUserRoleRaw(requestParameters: GetDefaultUserRoleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespName>> {
        if (requestParameters.user === null || requestParameters.user === undefined) {
            throw new runtime.RequiredError('user','Required parameter requestParameters.user was null or undefined when calling getDefaultUserRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/security/role/defaultRole/{user}`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters.user))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespNameFromJSON(jsonValue));
    }

    /**
     * Get a user\'s default role. The default role is implicitly created by the system when needed if it doesn\'t already exist. No authorization required.  A user\'s default role is constructed by prepending \'$$\' to the user\'s name.  This implies the maximum length of a user name is 58 since role names are limited to 60 characters.  
     */
    async getDefaultUserRole(requestParameters: GetDefaultUserRoleRequest, initOverrides?: RequestInit): Promise<RespName> {
        const response = await this.getDefaultUserRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the named role\'s definition.  A valid tenant must be specified as a query parameter.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getRoleByNameRaw(requestParameters: GetRoleByNameRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespRole>> {
        if (requestParameters.roleName === null || requestParameters.roleName === undefined) {
            throw new runtime.RequiredError('roleName','Required parameter requestParameters.roleName was null or undefined when calling getRoleByName.');
        }

        const queryParameters: any = {};

        if (requestParameters.tenant !== undefined) {
            queryParameters['tenant'] = requestParameters.tenant;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/{roleName}`.replace(`{${"roleName"}}`, encodeURIComponent(String(requestParameters.roleName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespRoleFromJSON(jsonValue));
    }

    /**
     * Get the named role\'s definition.  A valid tenant must be specified as a query parameter.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getRoleByName(requestParameters: GetRoleByNameRequest, initOverrides?: RequestInit): Promise<RespRole> {
        const response = await this.getRoleByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the names of all roles in the tenant in alphabetic order.  Future enhancements will include search filtering.  A valid tenant must be specified as a query parameter.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getRoleNamesRaw(requestParameters: GetRoleNamesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespNameArray>> {
        const queryParameters: any = {};

        if (requestParameters.tenant !== undefined) {
            queryParameters['tenant'] = requestParameters.tenant;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespNameArrayFromJSON(jsonValue));
    }

    /**
     * Get the names of all roles in the tenant in alphabetic order.  Future enhancements will include search filtering.  A valid tenant must be specified as a query parameter.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getRoleNames(requestParameters: GetRoleNamesRequest, initOverrides?: RequestInit): Promise<RespNameArray> {
        const response = await this.getRoleNamesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the named role\'s permissions.  By default, all permissions assigned to the role, whether directly and transitively through child roles, are returned.  Set the immediate query parameter to only retrieve permissions directly assigned to the role.  A valid tenant must be specified.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getRolePermissionsRaw(requestParameters: GetRolePermissionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespNameArray>> {
        if (requestParameters.roleName === null || requestParameters.roleName === undefined) {
            throw new runtime.RequiredError('roleName','Required parameter requestParameters.roleName was null or undefined when calling getRolePermissions.');
        }

        const queryParameters: any = {};

        if (requestParameters.tenant !== undefined) {
            queryParameters['tenant'] = requestParameters.tenant;
        }

        if (requestParameters.immediate !== undefined) {
            queryParameters['immediate'] = requestParameters.immediate;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/{roleName}/perms`.replace(`{${"roleName"}}`, encodeURIComponent(String(requestParameters.roleName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespNameArrayFromJSON(jsonValue));
    }

    /**
     * Get the named role\'s permissions.  By default, all permissions assigned to the role, whether directly and transitively through child roles, are returned.  Set the immediate query parameter to only retrieve permissions directly assigned to the role.  A valid tenant must be specified.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async getRolePermissions(requestParameters: GetRolePermissionsRequest, initOverrides?: RequestInit): Promise<RespNameArray> {
        const response = await this.getRolePermissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This read-only endpoint previews the transformations that would take place if the same input was used on a replacePathPrefix POST call. This call is also implemented as a POST so that the same input as used on replacePathPrefix can be used here, but this call changes nothing.  This endpoint can be used to get an accounting of existing system/path combinations that match the input specification. Such information is useful when trying to duplicate a set of permissions. For example, one may want to copy a file subtree to another location and assign the same permissions to the new subtree as currently exist on the original subtree. One could use  this call to calculate the users that should be granted permission on the new subtree.  The optional parameters are roleName, oldPrefix and newPrefix. No wildcards are defined for the path prefix parameters.  When roleName is specified then only permissions assigned to that role are considered.  When the oldPrefix parameter is provided, it\'s used to filter out permissions whose paths do not begin with the specified string; when not provided, no path prefix filtering occurs.  When the newPrefix parameter is not provided no new characters are prepended to the new path, effectively just removing the oldPrefix from the new path. When neither oldPrefix nor newPrefix are provided, no path transformation occurs, though system IDs can still be transformed.  The result object contains an array of transformation objects, each of which contains the unique permission sequence number, the existing permission that matched the search criteria and the new permission if the specified transformations were applied.  A valid tenant and user must be specified in the request body.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async previewPathPrefixRaw(requestParameters: PreviewPathPrefixRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespPathPrefixes>> {
        if (requestParameters.reqPreviewPathPrefix === null || requestParameters.reqPreviewPathPrefix === undefined) {
            throw new runtime.RequiredError('reqPreviewPathPrefix','Required parameter requestParameters.reqPreviewPathPrefix was null or undefined when calling previewPathPrefix.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/previewPathPrefix`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqPreviewPathPrefixToJSON(requestParameters.reqPreviewPathPrefix),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespPathPrefixesFromJSON(jsonValue));
    }

    /**
     * This read-only endpoint previews the transformations that would take place if the same input was used on a replacePathPrefix POST call. This call is also implemented as a POST so that the same input as used on replacePathPrefix can be used here, but this call changes nothing.  This endpoint can be used to get an accounting of existing system/path combinations that match the input specification. Such information is useful when trying to duplicate a set of permissions. For example, one may want to copy a file subtree to another location and assign the same permissions to the new subtree as currently exist on the original subtree. One could use  this call to calculate the users that should be granted permission on the new subtree.  The optional parameters are roleName, oldPrefix and newPrefix. No wildcards are defined for the path prefix parameters.  When roleName is specified then only permissions assigned to that role are considered.  When the oldPrefix parameter is provided, it\'s used to filter out permissions whose paths do not begin with the specified string; when not provided, no path prefix filtering occurs.  When the newPrefix parameter is not provided no new characters are prepended to the new path, effectively just removing the oldPrefix from the new path. When neither oldPrefix nor newPrefix are provided, no path transformation occurs, though system IDs can still be transformed.  The result object contains an array of transformation objects, each of which contains the unique permission sequence number, the existing permission that matched the search criteria and the new permission if the specified transformations were applied.  A valid tenant and user must be specified in the request body.  This request is authorized if the requestor is a user that has access to the specified tenant or if the requestor is a service.
     */
    async previewPathPrefix(requestParameters: PreviewPathPrefixRequest, initOverrides?: RequestInit): Promise<RespPathPrefixes> {
        const response = await this.previewPathPrefixRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a child role from a parent role using a request body.  A valid tenant and user must be specified in the request body.  The user@tenant identity specified in JWT is authorized to make this request only if that user is an administrator or if they own the parent role.
     */
    async removeChildRoleRaw(requestParameters: RemoveChildRoleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqRemoveChildRole === null || requestParameters.reqRemoveChildRole === undefined) {
            throw new runtime.RequiredError('reqRemoveChildRole','Required parameter requestParameters.reqRemoveChildRole was null or undefined when calling removeChildRole.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/removeChild`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqRemoveChildRoleToJSON(requestParameters.reqRemoveChildRole),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Remove a child role from a parent role using a request body.  A valid tenant and user must be specified in the request body.  The user@tenant identity specified in JWT is authorized to make this request only if that user is an administrator or if they own the parent role.
     */
    async removeChildRole(requestParameters: RemoveChildRoleRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.removeChildRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a permission from a role using a request body.  A valid role, roleTenant and permission must be specified in the request body.  Only the role owner or administrators are authorized to make this call.
     */
    async removeRolePermissionRaw(requestParameters: RemoveRolePermissionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqRemoveRolePermission === null || requestParameters.reqRemoveRolePermission === undefined) {
            throw new runtime.RequiredError('reqRemoveRolePermission','Required parameter requestParameters.reqRemoveRolePermission was null or undefined when calling removeRolePermission.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/removePerm`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqRemoveRolePermissionToJSON(requestParameters.reqRemoveRolePermission),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Remove a permission from a role using a request body.  A valid role, roleTenant and permission must be specified in the request body.  Only the role owner or administrators are authorized to make this call.
     */
    async removeRolePermission(requestParameters: RemoveRolePermissionRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.removeRolePermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace the text in a permission specification when its last component defines an *extended path attribute*.  Extended path attributes enhance the standard Shiro matching algorithm with one that treats designated components in a permission specification as a path name, such as a posix file or directory path name.  This request is useful when files or directories have been renamed or moved and their authorizations need to be adjusted.  Consider, for example, permissions that conform to the following specification:        files:tenantId:op:systemId:path  By definition, the last component is an extended path attribute whose content can be changed by replacePathPrefix requests.  Specifically, paths that begin with the oldPrefix will have that prefix replaced with the newPrefix value.  Replacement only occurs on permissions that also match the schema and oldSystemId parameter values.  The systemId attribute is required to immediately precede the path attribute, which must be the last attribute.  Additionally, the oldSystemId is replaced with the newSystemId when a match is found.  If a roleName is provided, then replacement is limited to permissions defined only in that role.  Otherwise, permissions in all roles that meet the other matching criteria will be considered.  The optional parameters are roleName, oldPrefix and newPrefix. No wildcards are defined for the path prefix parameters.  When roleName is specified then only permissions assigned to that role are considered.  When the oldPrefix parameter is provided, it\'s used to filter out permissions whose paths do not begin with the specified string; when not provided, no path prefix filtering occurs.  When the newPrefix parameter is not provided no new characters are prepended to the new path, effectively just removing the oldPrefix from the new path. When neither oldPrefix nor newPrefix are provided, no path transformation occurs, though system IDs can still be transformed.  The previewPathPrefix request provides a way to do a dry run using the same input as this request. The preview call calculates the permissions that would change and what their new values would be, but it does not actually change those permissions as replacePathPrefix does.  The input parameters are passed in the payload of this request.  The response indicates the number of changed permission specifications.  The path prefix replacement operation is authorized if the user@tenant in the JWT represents a tenant administrator or the Files service.
     */
    async replacePathPrefixRaw(requestParameters: ReplacePathPrefixRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.reqReplacePathPrefix === null || requestParameters.reqReplacePathPrefix === undefined) {
            throw new runtime.RequiredError('reqReplacePathPrefix','Required parameter requestParameters.reqReplacePathPrefix was null or undefined when calling replacePathPrefix.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/replacePathPrefix`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqReplacePathPrefixToJSON(requestParameters.reqReplacePathPrefix),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Replace the text in a permission specification when its last component defines an *extended path attribute*.  Extended path attributes enhance the standard Shiro matching algorithm with one that treats designated components in a permission specification as a path name, such as a posix file or directory path name.  This request is useful when files or directories have been renamed or moved and their authorizations need to be adjusted.  Consider, for example, permissions that conform to the following specification:        files:tenantId:op:systemId:path  By definition, the last component is an extended path attribute whose content can be changed by replacePathPrefix requests.  Specifically, paths that begin with the oldPrefix will have that prefix replaced with the newPrefix value.  Replacement only occurs on permissions that also match the schema and oldSystemId parameter values.  The systemId attribute is required to immediately precede the path attribute, which must be the last attribute.  Additionally, the oldSystemId is replaced with the newSystemId when a match is found.  If a roleName is provided, then replacement is limited to permissions defined only in that role.  Otherwise, permissions in all roles that meet the other matching criteria will be considered.  The optional parameters are roleName, oldPrefix and newPrefix. No wildcards are defined for the path prefix parameters.  When roleName is specified then only permissions assigned to that role are considered.  When the oldPrefix parameter is provided, it\'s used to filter out permissions whose paths do not begin with the specified string; when not provided, no path prefix filtering occurs.  When the newPrefix parameter is not provided no new characters are prepended to the new path, effectively just removing the oldPrefix from the new path. When neither oldPrefix nor newPrefix are provided, no path transformation occurs, though system IDs can still be transformed.  The previewPathPrefix request provides a way to do a dry run using the same input as this request. The preview call calculates the permissions that would change and what their new values would be, but it does not actually change those permissions as replacePathPrefix does.  The input parameters are passed in the payload of this request.  The response indicates the number of changed permission specifications.  The path prefix replacement operation is authorized if the user@tenant in the JWT represents a tenant administrator or the Files service.
     */
    async replacePathPrefix(requestParameters: ReplacePathPrefixRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.replacePathPrefixRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing role\'s decription using a request body.  The size limit on a description is 2048 characters.  This request is authorized if the requestor is the role owner or an administrator.
     */
    async updateRoleDescriptionRaw(requestParameters: UpdateRoleDescriptionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespBasic>> {
        if (requestParameters.roleName === null || requestParameters.roleName === undefined) {
            throw new runtime.RequiredError('roleName','Required parameter requestParameters.roleName was null or undefined when calling updateRoleDescription.');
        }

        if (requestParameters.reqUpdateRoleDescription === null || requestParameters.reqUpdateRoleDescription === undefined) {
            throw new runtime.RequiredError('reqUpdateRoleDescription','Required parameter requestParameters.reqUpdateRoleDescription was null or undefined when calling updateRoleDescription.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/updateDesc/{roleName}`.replace(`{${"roleName"}}`, encodeURIComponent(String(requestParameters.roleName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqUpdateRoleDescriptionToJSON(requestParameters.reqUpdateRoleDescription),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespBasicFromJSON(jsonValue));
    }

    /**
     * Update an existing role\'s decription using a request body.  The size limit on a description is 2048 characters.  This request is authorized if the requestor is the role owner or an administrator.
     */
    async updateRoleDescription(requestParameters: UpdateRoleDescriptionRequest, initOverrides?: RequestInit): Promise<RespBasic> {
        const response = await this.updateRoleDescriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing role\'s name using a request body.  Role names are case sensitive, alphanumeric strings that can contain underscores but must begin with an alphabetic character.  The limit on role name is 58 characters.  This request is authorized if the requestor is the role owner or an administrator.
     */
    async updateRoleNameRaw(requestParameters: UpdateRoleNameRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespBasic>> {
        if (requestParameters.roleName === null || requestParameters.roleName === undefined) {
            throw new runtime.RequiredError('roleName','Required parameter requestParameters.roleName was null or undefined when calling updateRoleName.');
        }

        if (requestParameters.reqUpdateRoleName === null || requestParameters.reqUpdateRoleName === undefined) {
            throw new runtime.RequiredError('reqUpdateRoleName','Required parameter requestParameters.reqUpdateRoleName was null or undefined when calling updateRoleName.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/updateName/{roleName}`.replace(`{${"roleName"}}`, encodeURIComponent(String(requestParameters.roleName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqUpdateRoleNameToJSON(requestParameters.reqUpdateRoleName),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespBasicFromJSON(jsonValue));
    }

    /**
     * Update an existing role\'s name using a request body.  Role names are case sensitive, alphanumeric strings that can contain underscores but must begin with an alphabetic character.  The limit on role name is 58 characters.  This request is authorized if the requestor is the role owner or an administrator.
     */
    async updateRoleName(requestParameters: UpdateRoleNameRequest, initOverrides?: RequestInit): Promise<RespBasic> {
        const response = await this.updateRoleNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing role\'s owner using a request body. Required parameters in the payload are the *roleTenant*, which is the tenant of named role, and *newOwner*, which is the user to which role ownership is being transferred. The *newTenant* payload parameter is optional and only needed when the new owner resides in a different tenant than that of the current owner.  This request is authorized if the requestor is the role owner or an administrator. If a new tenant is specified, then the requestor must also be allowed to act in the new tenant.
     */
    async updateRoleOwnerRaw(requestParameters: UpdateRoleOwnerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespBasic>> {
        if (requestParameters.roleName === null || requestParameters.roleName === undefined) {
            throw new runtime.RequiredError('roleName','Required parameter requestParameters.roleName was null or undefined when calling updateRoleOwner.');
        }

        if (requestParameters.reqUpdateRoleOwner === null || requestParameters.reqUpdateRoleOwner === undefined) {
            throw new runtime.RequiredError('reqUpdateRoleOwner','Required parameter requestParameters.reqUpdateRoleOwner was null or undefined when calling updateRoleOwner.');
        }

        const queryParameters: any = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/security/role/updateOwner/{roleName}`.replace(`{${"roleName"}}`, encodeURIComponent(String(requestParameters.roleName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqUpdateRoleOwnerToJSON(requestParameters.reqUpdateRoleOwner),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespBasicFromJSON(jsonValue));
    }

    /**
     * Update an existing role\'s owner using a request body. Required parameters in the payload are the *roleTenant*, which is the tenant of named role, and *newOwner*, which is the user to which role ownership is being transferred. The *newTenant* payload parameter is optional and only needed when the new owner resides in a different tenant than that of the current owner.  This request is authorized if the requestor is the role owner or an administrator. If a new tenant is specified, then the requestor must also be allowed to act in the new tenant.
     */
    async updateRoleOwner(requestParameters: UpdateRoleOwnerRequest, initOverrides?: RequestInit): Promise<RespBasic> {
        const response = await this.updateRoleOwnerRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
