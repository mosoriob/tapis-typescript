/* tslint:disable */
/* eslint-disable */
/**
 * Tapis Notifications API
 * The Tapis Notifications API provides for management of subscriptions and event publication
 *
 * The version of the OpenAPI document: 1.6.1
 * Contact: cicsupport@tacc.utexas.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ReqPatchSubscription,
    ReqPatchSubscriptionFromJSON,
    ReqPatchSubscriptionToJSON,
    ReqPostSubscription,
    ReqPostSubscriptionFromJSON,
    ReqPostSubscriptionToJSON,
    ReqSearchSubscriptions,
    ReqSearchSubscriptionsFromJSON,
    ReqSearchSubscriptionsToJSON,
    RespBasic,
    RespBasicFromJSON,
    RespBasicToJSON,
    RespBoolean,
    RespBooleanFromJSON,
    RespBooleanToJSON,
    RespChangeCount,
    RespChangeCountFromJSON,
    RespChangeCountToJSON,
    RespResourceUrl,
    RespResourceUrlFromJSON,
    RespResourceUrlToJSON,
    RespSubscription,
    RespSubscriptionFromJSON,
    RespSubscriptionToJSON,
    RespSubscriptions,
    RespSubscriptionsFromJSON,
    RespSubscriptionsToJSON,
} from '../models';

export interface DeleteSubscriptionByNameRequest {
    name: string;
    ownedBy?: string;
}

export interface DeleteSubscriptionByUuidRequest {
    uuid: string;
}

export interface DeleteSubscriptionsBySubjectRequest {
    subject: string;
    ownedBy?: string;
    anyOwner?: boolean;
}

export interface DisableSubscriptionRequest {
    name: string;
    ownedBy?: string;
}

export interface EnableSubscriptionRequest {
    name: string;
    ownedBy?: string;
}

export interface GetSubscriptionByNameRequest {
    name: string;
    select?: string;
    ownedBy?: string;
}

export interface GetSubscriptionByUuidRequest {
    uuid: string;
    select?: string;
}

export interface GetSubscriptionsRequest {
    search?: string;
    limit?: number;
    orderBy?: string;
    skip?: number;
    startAfter?: string;
    computeTotal?: boolean;
    select?: string;
    ownedBy?: string;
    anyOwner?: boolean;
}

export interface IsEnabledRequest {
    name: string;
    ownedBy?: string;
}

export interface PatchSubscriptionByNameRequest {
    name: string;
    reqPatchSubscription: ReqPatchSubscription;
    ownedBy?: string;
}

export interface PostSubscriptionRequest {
    reqPostSubscription: ReqPostSubscription;
}

export interface SearchSubscriptionsQueryParametersRequest {
    freeFormParameterName?: { [key: string]: string; };
    limit?: number;
    orderBy?: string;
    skip?: number;
    startAfter?: string;
    computeTotal?: boolean;
    select?: string;
    ownedBy?: string;
}

export interface SearchSubscriptionsRequestBodyRequest {
    reqSearchSubscriptions: ReqSearchSubscriptions;
    limit?: number;
    orderBy?: string;
    skip?: number;
    startAfter?: string;
    computeTotal?: boolean;
    select?: string;
    ownedBy?: string;
}

export interface UpdateTTLRequest {
    name: string;
    ttlMinutes: number;
    ownedBy?: string;
}

/**
 * 
 */
export class SubscriptionsApi extends runtime.BaseAPI {

    /**
     * Delete a subscription. Only services may perform this operation.  Events will stop being delivered. Subscription must be re-created to resume event delivery. Query parameter *ownedBy* may be used to delete a subscription owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async deleteSubscriptionByNameRaw(requestParameters: DeleteSubscriptionByNameRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteSubscriptionByName.');
        }

        const queryParameters: any = {};

        if (requestParameters.ownedBy !== undefined) {
            queryParameters['ownedBy'] = requestParameters.ownedBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/byName/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Delete a subscription. Only services may perform this operation.  Events will stop being delivered. Subscription must be re-created to resume event delivery. Query parameter *ownedBy* may be used to delete a subscription owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async deleteSubscriptionByName(requestParameters: DeleteSubscriptionByNameRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.deleteSubscriptionByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a subscription whose UUID matches the provided value. Only services may perform this operation. 
     */
    async deleteSubscriptionByUuidRaw(requestParameters: DeleteSubscriptionByUuidRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling deleteSubscriptionByUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/byUuid/{uuid}`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Delete a subscription whose UUID matches the provided value. Only services may perform this operation. 
     */
    async deleteSubscriptionByUuid(requestParameters: DeleteSubscriptionByUuidRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.deleteSubscriptionByUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete all subscriptions whose *subjectFilter* matches the specific *subject* provided. Only services may perform this operation.  Query parameter *ownedBy* may be used to delete subscriptions owned by a user other than the requesting user. Ignored if *anyOwner* is set to true. Only services or tenant administrators may set *ownedBy*.  Query parameter *anyOwner* may be used to delete subscriptions owned by any user. Query parameter *anyOwner* takes precedence over parameter *ownedBy*. Only services may set *anyOwner*. 
     */
    async deleteSubscriptionsBySubjectRaw(requestParameters: DeleteSubscriptionsBySubjectRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.subject === null || requestParameters.subject === undefined) {
            throw new runtime.RequiredError('subject','Required parameter requestParameters.subject was null or undefined when calling deleteSubscriptionsBySubject.');
        }

        const queryParameters: any = {};

        if (requestParameters.ownedBy !== undefined) {
            queryParameters['ownedBy'] = requestParameters.ownedBy;
        }

        if (requestParameters.anyOwner !== undefined) {
            queryParameters['anyOwner'] = requestParameters.anyOwner;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/bySubject/{subject}`.replace(`{${"subject"}}`, encodeURIComponent(String(requestParameters.subject))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Delete all subscriptions whose *subjectFilter* matches the specific *subject* provided. Only services may perform this operation.  Query parameter *ownedBy* may be used to delete subscriptions owned by a user other than the requesting user. Ignored if *anyOwner* is set to true. Only services or tenant administrators may set *ownedBy*.  Query parameter *anyOwner* may be used to delete subscriptions owned by any user. Query parameter *anyOwner* takes precedence over parameter *ownedBy*. Only services may set *anyOwner*. 
     */
    async deleteSubscriptionsBySubject(requestParameters: DeleteSubscriptionsBySubjectRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.deleteSubscriptionsBySubjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a subscription to be inactive. Only services may perform this operation.  Matching events will stop being delivered. Query parameter *ownedBy* may be used to disable a subscription owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async disableSubscriptionRaw(requestParameters: DisableSubscriptionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling disableSubscription.');
        }

        const queryParameters: any = {};

        if (requestParameters.ownedBy !== undefined) {
            queryParameters['ownedBy'] = requestParameters.ownedBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/{name}/disable`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Update a subscription to be inactive. Only services may perform this operation.  Matching events will stop being delivered. Query parameter *ownedBy* may be used to disable a subscription owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async disableSubscription(requestParameters: DisableSubscriptionRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.disableSubscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a subscription to be active. Only services may perform this operation.  Matching events will start being delivered. Query parameter *ownedBy* may be used to enable a subscription owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async enableSubscriptionRaw(requestParameters: EnableSubscriptionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling enableSubscription.');
        }

        const queryParameters: any = {};

        if (requestParameters.ownedBy !== undefined) {
            queryParameters['ownedBy'] = requestParameters.ownedBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/{name}/enable`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Update a subscription to be active. Only services may perform this operation.  Matching events will start being delivered. Query parameter *ownedBy* may be used to enable a subscription owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async enableSubscription(requestParameters: EnableSubscriptionRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.enableSubscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a subscription owned by the requesting user and whose name matches the provided value. Query parameter *ownedBy* may be used to retrieve a subscription owned by another user. Only services or tenant administrators may set the *ownedBy* query parameter.  Summary of subscription attributes. For details please see *postSubscription*:   - owner: Tapis user who owns the subscription.   - name: Short descriptive name.   - description: Optional more verbose description.   - enabled: Indicates if subscription is currently active.   - typeFilter: Filter to use when matching events. Format is *service.category.detail*. Each field may be a specific type or the wildcard character *.   - subjectFilter: Filter to use when matching events. Filter for subject. May be wildcard character *.   - deliveryTargets: List of delivery targets to be used when delivering a matching event.   - ttlMinutes: Time to live in minutes. 0 indicates no expiration.   - uuid: A UUID generated by the service.   - expiry: Time at which the subscription expires and will be deleted. Maintained by the service.   - created: When created. Maintained by the service.   - updated: When last updated. Maintained by the service. 
     */
    async getSubscriptionByNameRaw(requestParameters: GetSubscriptionByNameRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespSubscription>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getSubscriptionByName.');
        }

        const queryParameters: any = {};

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        if (requestParameters.ownedBy !== undefined) {
            queryParameters['ownedBy'] = requestParameters.ownedBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/byName/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespSubscriptionFromJSON(jsonValue));
    }

    /**
     * Retrieve a subscription owned by the requesting user and whose name matches the provided value. Query parameter *ownedBy* may be used to retrieve a subscription owned by another user. Only services or tenant administrators may set the *ownedBy* query parameter.  Summary of subscription attributes. For details please see *postSubscription*:   - owner: Tapis user who owns the subscription.   - name: Short descriptive name.   - description: Optional more verbose description.   - enabled: Indicates if subscription is currently active.   - typeFilter: Filter to use when matching events. Format is *service.category.detail*. Each field may be a specific type or the wildcard character *.   - subjectFilter: Filter to use when matching events. Filter for subject. May be wildcard character *.   - deliveryTargets: List of delivery targets to be used when delivering a matching event.   - ttlMinutes: Time to live in minutes. 0 indicates no expiration.   - uuid: A UUID generated by the service.   - expiry: Time at which the subscription expires and will be deleted. Maintained by the service.   - created: When created. Maintained by the service.   - updated: When last updated. Maintained by the service. 
     */
    async getSubscriptionByName(requestParameters: GetSubscriptionByNameRequest, initOverrides?: RequestInit): Promise<RespSubscription> {
        const response = await this.getSubscriptionByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a subscription whose UUID matches the provided value.  Summary of subscription attributes. For details please see *postSubscription*:   - owner: Tapis user who owns the subscription.   - name: Short descriptive name.   - description: Optional more verbose description.   - enabled: Indicates if subscription is currently active.   - typeFilter: Filter to use when matching events. Format is *service.category.detail*. Each field may be a specific type or the wildcard character *.   - subjectFilter: Filter to use when matching events. Filter for subject. May be wildcard character *.   - deliveryTargets: List of delivery targets to be used when delivering a matching event.   - ttlMinutes: Time to live in minutes. 0 indicates no expiration.   - uuid: A UUID generated by the service.   - expiry: Time at which the subscription expires and will be deleted. Maintained by the service.   - created: When created. Maintained by the service.   - updated: When last updated. Maintained by the service. 
     */
    async getSubscriptionByUuidRaw(requestParameters: GetSubscriptionByUuidRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespSubscription>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getSubscriptionByUuid.');
        }

        const queryParameters: any = {};

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/byUuid/{uuid}`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespSubscriptionFromJSON(jsonValue));
    }

    /**
     * Retrieve a subscription whose UUID matches the provided value.  Summary of subscription attributes. For details please see *postSubscription*:   - owner: Tapis user who owns the subscription.   - name: Short descriptive name.   - description: Optional more verbose description.   - enabled: Indicates if subscription is currently active.   - typeFilter: Filter to use when matching events. Format is *service.category.detail*. Each field may be a specific type or the wildcard character *.   - subjectFilter: Filter to use when matching events. Filter for subject. May be wildcard character *.   - deliveryTargets: List of delivery targets to be used when delivering a matching event.   - ttlMinutes: Time to live in minutes. 0 indicates no expiration.   - uuid: A UUID generated by the service.   - expiry: Time at which the subscription expires and will be deleted. Maintained by the service.   - created: When created. Maintained by the service.   - updated: When last updated. Maintained by the service. 
     */
    async getSubscriptionByUuid(requestParameters: GetSubscriptionByUuidRequest, initOverrides?: RequestInit): Promise<RespSubscription> {
        const response = await this.getSubscriptionByUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve list of subscriptions owned by the requesting user. Use search and select query parameters to limit results.  Query parameter *ownedBy* may be used to retrieve subscriptions owned by a user other than the requesting user. Ignored if *anyOwner* is set to true. Only services or tenant administrators may set *ownedBy*.  Query parameter *anyOwner* may be used to retrieve all subscriptions owned by any user. Query parameter *anyOwner* takes precedence over parameter *ownedBy*. Only services may set *anyOwner*. 
     */
    async getSubscriptionsRaw(requestParameters: GetSubscriptionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespSubscriptions>> {
        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.skip !== undefined) {
            queryParameters['skip'] = requestParameters.skip;
        }

        if (requestParameters.startAfter !== undefined) {
            queryParameters['startAfter'] = requestParameters.startAfter;
        }

        if (requestParameters.computeTotal !== undefined) {
            queryParameters['computeTotal'] = requestParameters.computeTotal;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        if (requestParameters.ownedBy !== undefined) {
            queryParameters['ownedBy'] = requestParameters.ownedBy;
        }

        if (requestParameters.anyOwner !== undefined) {
            queryParameters['anyOwner'] = requestParameters.anyOwner;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespSubscriptionsFromJSON(jsonValue));
    }

    /**
     * Retrieve list of subscriptions owned by the requesting user. Use search and select query parameters to limit results.  Query parameter *ownedBy* may be used to retrieve subscriptions owned by a user other than the requesting user. Ignored if *anyOwner* is set to true. Only services or tenant administrators may set *ownedBy*.  Query parameter *anyOwner* may be used to retrieve all subscriptions owned by any user. Query parameter *anyOwner* takes precedence over parameter *ownedBy*. Only services may set *anyOwner*. 
     */
    async getSubscriptions(requestParameters: GetSubscriptionsRequest, initOverrides?: RequestInit): Promise<RespSubscriptions> {
        const response = await this.getSubscriptionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check if a subscription owned by the requesting user is currently active. Query parameter *ownedBy* may be used to check a subscription owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async isEnabledRaw(requestParameters: IsEnabledRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespBoolean>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling isEnabled.');
        }

        const queryParameters: any = {};

        if (requestParameters.ownedBy !== undefined) {
            queryParameters['ownedBy'] = requestParameters.ownedBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/{name}/isEnabled`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespBooleanFromJSON(jsonValue));
    }

    /**
     * Check if a subscription owned by the requesting user is currently active. Query parameter *ownedBy* may be used to check a subscription owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async isEnabled(requestParameters: IsEnabledRequest, initOverrides?: RequestInit): Promise<RespBoolean> {
        const response = await this.isEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update selected attributes of a subscription. Only services may perform this operation.  Request body may only contain updatable attributes. Subscription must exist. Query parameter *ownedBy* may be used to patch a subscription owned by another user. Only services or tenant administrators may set *ownedBy*.  Attributes that may not be updated via PATCH are    - name   - owner   - enabled   - ttlMinutes  Note that the attributes *enabled* and *ttlMinutes* may be modified using other endpoints. 
     */
    async patchSubscriptionByNameRaw(requestParameters: PatchSubscriptionByNameRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespResourceUrl>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchSubscriptionByName.');
        }

        if (requestParameters.reqPatchSubscription === null || requestParameters.reqPatchSubscription === undefined) {
            throw new runtime.RequiredError('reqPatchSubscription','Required parameter requestParameters.reqPatchSubscription was null or undefined when calling patchSubscriptionByName.');
        }

        const queryParameters: any = {};

        if (requestParameters.ownedBy !== undefined) {
            queryParameters['ownedBy'] = requestParameters.ownedBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/byName/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ReqPatchSubscriptionToJSON(requestParameters.reqPatchSubscription),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespResourceUrlFromJSON(jsonValue));
    }

    /**
     * Update selected attributes of a subscription. Only services may perform this operation.  Request body may only contain updatable attributes. Subscription must exist. Query parameter *ownedBy* may be used to patch a subscription owned by another user. Only services or tenant administrators may set *ownedBy*.  Attributes that may not be updated via PATCH are    - name   - owner   - enabled   - ttlMinutes  Note that the attributes *enabled* and *ttlMinutes* may be modified using other endpoints. 
     */
    async patchSubscriptionByName(requestParameters: PatchSubscriptionByNameRequest, initOverrides?: RequestInit): Promise<RespResourceUrl> {
        const response = await this.patchSubscriptionByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a subscription using a request body. Only services may perform this operation.  For each owner the *name* must be unique and can be composed of alphanumeric characters and the following special characters [-._~]. If attribute *name* is not provided then the service will generate one. The attributes *typeFilter*, *subjectFilter* and *deliveryTargets* are required.  Subscription attributes:   - name: Optional short descriptive name. *owner+name* must be unique. If one is not provided the service will create one.   - description: Optional more verbose description. Maximum length of 2048 characters.   - owner: A specific user set at create time. Default is *${apiUserId}*.   - enabled: Indicates if subscription is active. By default enabled is true.   - typeFilter: Filter to use when matching events. Filter for event type. Has three dot separated parts: *service*, *category* and *detail*. Each field may be a specific type or the wildcard character. Examples are *jobs.job.complete*, *jobs.new_status.\\**.   - subjectFilter: Filter to use when matching events. Filter for subject. This may be a specific subject such as a job Id or the wildcard character *.   - deliveryTargets: List of delivery targets to be used when delivering a matching event. Must have at least one. Each target includes delivery method (EMAIL or WEBHOOK) and delivery address.   - ttlMinutes: Time to live in minutes specified when subscription is created or TTL is updated. Service will compute expiry based on TTL. Default is one week from creation. Value of 0 indicates no expiration. 
     */
    async postSubscriptionRaw(requestParameters: PostSubscriptionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespResourceUrl>> {
        if (requestParameters.reqPostSubscription === null || requestParameters.reqPostSubscription === undefined) {
            throw new runtime.RequiredError('reqPostSubscription','Required parameter requestParameters.reqPostSubscription was null or undefined when calling postSubscription.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqPostSubscriptionToJSON(requestParameters.reqPostSubscription),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespResourceUrlFromJSON(jsonValue));
    }

    /**
     * Create a subscription using a request body. Only services may perform this operation.  For each owner the *name* must be unique and can be composed of alphanumeric characters and the following special characters [-._~]. If attribute *name* is not provided then the service will generate one. The attributes *typeFilter*, *subjectFilter* and *deliveryTargets* are required.  Subscription attributes:   - name: Optional short descriptive name. *owner+name* must be unique. If one is not provided the service will create one.   - description: Optional more verbose description. Maximum length of 2048 characters.   - owner: A specific user set at create time. Default is *${apiUserId}*.   - enabled: Indicates if subscription is active. By default enabled is true.   - typeFilter: Filter to use when matching events. Filter for event type. Has three dot separated parts: *service*, *category* and *detail*. Each field may be a specific type or the wildcard character. Examples are *jobs.job.complete*, *jobs.new_status.\\**.   - subjectFilter: Filter to use when matching events. Filter for subject. This may be a specific subject such as a job Id or the wildcard character *.   - deliveryTargets: List of delivery targets to be used when delivering a matching event. Must have at least one. Each target includes delivery method (EMAIL or WEBHOOK) and delivery address.   - ttlMinutes: Time to live in minutes specified when subscription is created or TTL is updated. Service will compute expiry based on TTL. Default is one week from creation. Value of 0 indicates no expiration. 
     */
    async postSubscription(requestParameters: PostSubscriptionRequest, initOverrides?: RequestInit): Promise<RespResourceUrl> {
        const response = await this.postSubscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve details for subscriptions owned by the requesting user. Use query parameters to specify search conditions. For example name.eq=MySubscription. Query parameter *ownedBy* may be used to retrieve subscriptions owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async searchSubscriptionsQueryParametersRaw(requestParameters: SearchSubscriptionsQueryParametersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespSubscriptions>> {
        const queryParameters: any = {};

        if (requestParameters.freeFormParameterName !== undefined) {
            queryParameters['freeFormParameterName'] = requestParameters.freeFormParameterName;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.skip !== undefined) {
            queryParameters['skip'] = requestParameters.skip;
        }

        if (requestParameters.startAfter !== undefined) {
            queryParameters['startAfter'] = requestParameters.startAfter;
        }

        if (requestParameters.computeTotal !== undefined) {
            queryParameters['computeTotal'] = requestParameters.computeTotal;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        if (requestParameters.ownedBy !== undefined) {
            queryParameters['ownedBy'] = requestParameters.ownedBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespSubscriptionsFromJSON(jsonValue));
    }

    /**
     * Retrieve details for subscriptions owned by the requesting user. Use query parameters to specify search conditions. For example name.eq=MySubscription. Query parameter *ownedBy* may be used to retrieve subscriptions owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async searchSubscriptionsQueryParameters(requestParameters: SearchSubscriptionsQueryParametersRequest, initOverrides?: RequestInit): Promise<RespSubscriptions> {
        const response = await this.searchSubscriptionsQueryParametersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve details for subscriptions owned by the requesting user. Use request body to specify SQL-like search conditions. Query parameter *ownedBy* may be used to retrieve subscriptions owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async searchSubscriptionsRequestBodyRaw(requestParameters: SearchSubscriptionsRequestBodyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespSubscriptions>> {
        if (requestParameters.reqSearchSubscriptions === null || requestParameters.reqSearchSubscriptions === undefined) {
            throw new runtime.RequiredError('reqSearchSubscriptions','Required parameter requestParameters.reqSearchSubscriptions was null or undefined when calling searchSubscriptionsRequestBody.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.skip !== undefined) {
            queryParameters['skip'] = requestParameters.skip;
        }

        if (requestParameters.startAfter !== undefined) {
            queryParameters['startAfter'] = requestParameters.startAfter;
        }

        if (requestParameters.computeTotal !== undefined) {
            queryParameters['computeTotal'] = requestParameters.computeTotal;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        if (requestParameters.ownedBy !== undefined) {
            queryParameters['ownedBy'] = requestParameters.ownedBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqSearchSubscriptionsToJSON(requestParameters.reqSearchSubscriptions),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespSubscriptionsFromJSON(jsonValue));
    }

    /**
     * Retrieve details for subscriptions owned by the requesting user. Use request body to specify SQL-like search conditions. Query parameter *ownedBy* may be used to retrieve subscriptions owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async searchSubscriptionsRequestBody(requestParameters: SearchSubscriptionsRequestBodyRequest, initOverrides?: RequestInit): Promise<RespSubscriptions> {
        const response = await this.searchSubscriptionsRequestBodyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Time-To-Live (TTL) for a subscription. Only services may perform this operation.  TTL provided as number of minutes. Use 0 to indicate subscription should never expire. Query parameter *ownedBy* may be used to update a subscription owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async updateTTLRaw(requestParameters: UpdateTTLRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling updateTTL.');
        }

        if (requestParameters.ttlMinutes === null || requestParameters.ttlMinutes === undefined) {
            throw new runtime.RequiredError('ttlMinutes','Required parameter requestParameters.ttlMinutes was null or undefined when calling updateTTL.');
        }

        const queryParameters: any = {};

        if (requestParameters.ownedBy !== undefined) {
            queryParameters['ownedBy'] = requestParameters.ownedBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/notifications/subscriptions/{name}/updateTTL/{ttlMinutes}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"ttlMinutes"}}`, encodeURIComponent(String(requestParameters.ttlMinutes))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Update Time-To-Live (TTL) for a subscription. Only services may perform this operation.  TTL provided as number of minutes. Use 0 to indicate subscription should never expire. Query parameter *ownedBy* may be used to update a subscription owned by another user. Only services or tenant administrators may set *ownedBy*. 
     */
    async updateTTL(requestParameters: UpdateTTLRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.updateTTLRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
